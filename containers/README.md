# Практическое занятие №1: Основные структуры данных, простые алгоритмы

## Часть 1

### Вычислительная сложность для алгоритмов контейнеров.

vector:
1) Вставка элемента в конец O(1). (Амортизированная)
2) Вставка элемента в начало O(n).
3) Линейный поиск O(n). (std::find)


list:
1) Вставка элемента в конец O(1).
2) Вставка элемента в начало O(1).
3) Линейный поиск O(n). (std::find)

set:
1) Вставка элемента O(log(n))
2) Бинарный поиск O(log(n)). (set::find)


### Замеры времени

Замеры были на release версии с флагом оптимизации -O2

Для N = 10000, M = N / 2

| Container\operation | Insert back | Insert begin | Search     |
|---------------------|-------------|--------------|------------|
| vector              | 0.000096 s  | 0.003867 s   | 0.010974 s |
| list                | 0.000466 s  | 0.000185 s   | 0.107328 s |
| set                 | 0.002041 s  | 0.002041 s   | 0.000984 s |


Для N = 100000, M = N / 2

| Container\operation  | Insert back | Insert begin | Search      |
|----------------------|-------------|--------------|-------------|
| vector               | 0.000853 s  | 0.626062 s   | 1.105788 s  |
| list                 | 0.005010 s  | 0.004799 s   | 11.25385 s  |
| set                  | 0.045282 s  | 0.045282 s   | 0.026066 s  |

Для N = 200000, M = N / 10

| Container\operation | Insert back | Insert begin | Search      |
|---------------------|-------------|--------------|-------------|
| vector              | 0.001658 s  | 3.081632 s   | 0.911624 s  |
| list                | 0.009615 s  | 0.003944 s   | 11.240931 s |
| set                 | 0.098147 s  | 0.098147 s   | 0.008017 s  |

Сравнительная разница в линейном поиске элемента в векторе и списке,
связана с большим временем доступа к элементу в списке, нежели в векторе.

### Вывод

1) Если придется многократно вставлять элементы в начало контейнера -
лучше всего подойдёт список, за счёт того, что создастся отдельный
узел, который будет связан со следующим элементом (в прошлом - первым).

2) Если прдется многократно вставлять элементы в конец контейнера -
лучше всего подойдёт вектор, за счёт того, что вектор дополнительно
резервирует память (отсюда и амортизированный расчёт сложности, так как
при очередной вставки в конец может закончится память и нужно будет
перевыделять память).

3) Если требуется быстрая вставка или поиск элемента в контейнере - 
лучше всего подойдёт множество, за счёт того - что оно представляет собой
бинарное дерево.


